<p>Consider a function with two variables, a scalar variable x and a matrix valued variable F (which is assumed to be default constructible in this example): \[f(x,F)=\sqrt{x}\mathrm{tr}(F).\]</p>

<pre class="code-style boxshadow">#include "fung.hh"

template &lt;class Mat&gt;
auto generateFunction()
{
  using namespace Fung;
  using FunG::LinearAlgebra::trace;
  
  auto x = variable&lt;0&gt;(0.);
  auto F = Variable&lt;Mat,1&gt;();

  return finalize( sqrt(x)*trace(F) );
}
</pre>

<p>When computing derivatives we now have to specify the variable ids for which the derivative will be computed. The same holds for setting the function values.</p>

<pre class="code-style boxshadow">auto f = generateFunction&lt;Mat&gt;();

f.template update&lt;0&gt;(x);
f.template update&lt;1&gt;(F);

double value       = f();
double df_dx       = f.template d1&lt;0&gt;(dx1);
double df_dF       = f.template d1&lt;1&gt;(dF)
double ddf_dFdx    = f.template d2&lt;1,0&gt;(dF,dx1);
double dddf_dxdxdF = f.template d3&lt;0,0,1&gt;(dx1,dx2,dF);
</pre> 

<p>The function <code>finalize</code> at the end of <code>generateFunction</code> is necessary to generate the suitable update function for f.</p>
