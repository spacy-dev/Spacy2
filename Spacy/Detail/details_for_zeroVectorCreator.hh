// This file was automatically generated by friendly type erasure.
// Please do not modify.

#pragma once

#include <functional>
#include <Spacy/Util/table_util.hh>
#include <Spacy/vector.hh>
#include <Spacy/vectorSpace.hh>

namespace Spacy
{
    namespace ZeroVectorCreatorDetail
    {
        template < class Interface >
        struct Functions
        {
            using delete_function = void ( * )( void* );
            using clone_function = void* (*)( void* );
            using call_const_VectorSpace_ptr_function = Vector ( * )( const Interface&, void*, const VectorSpace* V );

            delete_function del;
            clone_function clone;
            call_const_VectorSpace_ptr_function call_const_VectorSpace_ptr;
        };

        template < class Interface, class Impl >
        struct execution_wrapper
        {
            static Vector call_const_VectorSpace_ptr( const Interface& interface, void* impl, const VectorSpace* V )
            {
                return static_cast< const Impl* >( impl )->operator()( V );
            }
        };

        template < class Interface, class Impl >
        struct execution_wrapper< Interface, std::reference_wrapper< Impl > >
        {
            static Vector call_const_VectorSpace_ptr( const Interface& interface, void* impl, const VectorSpace* V )
            {
                return static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator()( V );
            }
        };

        template < class T >
        using TryMemFn_call_const_VectorSpace_ptr =
            decltype( std::declval< T >().operator()( std::declval< const VectorSpace* >() ) );
        template < class T, class = void >
        struct HasMemFn_call_const_VectorSpace_ptr : std::false_type
        {
        };
        template < class T >
        struct HasMemFn_call_const_VectorSpace_ptr<
            T, type_erasure_table_detail::voider< TryMemFn_call_const_VectorSpace_ptr< T > > > : std::true_type
        {
        };

        template < class T >
        using ZeroVectorCreatorConceptImpl =
            std::integral_constant< bool, HasMemFn_call_const_VectorSpace_ptr<
                                              type_erasure_table_detail::remove_reference_wrapper_t< T > >::value >;

        template < class Impl, class T, bool = std::is_same< Impl, T >::value >
        struct ZeroVectorCreatorConcept : std::false_type
        {
        };
        template < class Impl, class T >
        struct ZeroVectorCreatorConcept< Impl, T, false > : ZeroVectorCreatorConceptImpl< T >
        {
        };
    }
}
