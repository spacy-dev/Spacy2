\hypertarget{namespaceFunG}{}\section{Fun\+G Namespace Reference}
\label{namespaceFunG}\index{Fun\+G@{Fun\+G}}


Main namespace of the Fun\+G library.  


\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespaceFunG_1_1Checks}{Checks}
\begin{DoxyCompactList}\small\item\em Static checks for the presence of different operators and functions. \end{DoxyCompactList}\item 
 \hyperlink{namespaceFunG_1_1Concepts}{Concepts}
\begin{DoxyCompactList}\small\item\em Requirements on input types. \end{DoxyCompactList}\item 
 \hyperlink{namespaceFunG_1_1LinearAlgebra}{Linear\+Algebra}
\begin{DoxyCompactList}\small\item\em Functionality from linear algebra such as (modified) principal and mixed matrix invariants. \end{DoxyCompactList}\item 
 \hyperlink{namespaceFunG_1_1MathematicalOperations}{Mathematical\+Operations}
\begin{DoxyCompactList}\small\item\em Mathematical operations and corresponding differentation rules. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structFunG_1_1ASin}{A\+Sin}
\begin{DoxyCompactList}\small\item\em Arcsine function including first three derivatives (based on asin(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Constant}{Constant}
\begin{DoxyCompactList}\small\item\em Wrap a constant. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Cos}{Cos}
\begin{DoxyCompactList}\small\item\em Cosine function including first three derivatives (based on cos(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Decay}{Decay}
\begin{DoxyCompactList}\small\item\em \hyperlink{structFunG_1_1Identity}{Identity}, i.\+e. \hyperlink{structFunG_1_1Decay_a4b2916cbb7c8587ab3fccc9b896b9df4}{Decay$<$\+F$>$\+::type} == F. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Decay_3_01F_00_01void__t_3_01Checks_1_1TryNestedType__PlainObject_3_01F_01_4_01_4_01_4}{Decay$<$ F, void\+\_\+t$<$ Checks\+::\+Try\+Nested\+Type\+\_\+\+Plain\+Object$<$ F $>$ $>$ $>$}
\begin{DoxyCompactList}\small\item\em Underlying type for expression templates of the Eigen library. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Exp}{Exp}
\begin{DoxyCompactList}\small\item\em Exponential function including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Exp2}{Exp2}
\begin{DoxyCompactList}\small\item\em Function $2^x$ including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Identity}{Identity}
\begin{DoxyCompactList}\small\item\em Identity mapping $ f(x)=x $. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1IsArithmetic}{Is\+Arithmetic}
\begin{DoxyCompactList}\small\item\em Specialize this template class to register arithmetic types that are not built-\/in. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1LN}{L\+N}
\begin{DoxyCompactList}\small\item\em Natural logarithm including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Log10}{Log10}
\begin{DoxyCompactList}\small\item\em Common (base 10) logarithm including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Log2}{Log2}
\begin{DoxyCompactList}\small\item\em Base 2 logarithm including first three derivatives. \end{DoxyCompactList}\item 
class \hyperlink{classFunG_1_1NonSymmetricMatrixException}{Non\+Symmetric\+Matrix\+Exception}
\begin{DoxyCompactList}\small\item\em Exception for non-\/symmetric matrices if symmetric matrices are required. \end{DoxyCompactList}\item 
class \hyperlink{classFunG_1_1OutOfDomainException}{Out\+Of\+Domain\+Exception}
\begin{DoxyCompactList}\small\item\em Exception for scalar function arguments that are outside the domain of the function. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Pow}{Pow}
\begin{DoxyCompactList}\small\item\em Power function with rational exponent $ k = \frac{dividend}{divisor} $ including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Sin}{Sin}
\begin{DoxyCompactList}\small\item\em Sine function including first three derivatives (based on sin(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Tan}{Tan}
\begin{DoxyCompactList}\small\item\em Tangent function including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Variable}{Variable}
\begin{DoxyCompactList}\small\item\em Independent variable. Can be uniquely identified by its id. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Zero}{Zero}
\begin{DoxyCompactList}\small\item\em Specialize this struct for your matrix type if a zero matrix cannot be generated via Matrix(0.). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Zero_3_01Matrix_00_01void__t_3_01Checks_1_1TryCallToFill_3_01Matrix_01_4_01_4_01_4}{Zero$<$ Matrix, void\+\_\+t$<$ Checks\+::\+Try\+Call\+To\+Fill$<$ Matrix $>$ $>$ $>$}
\begin{DoxyCompactList}\small\item\em Specialization for the case that a matrix can be set to zero by calling the member function fill(0). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{group__CMathGroup_gaca80e773d5886f47cd49dc19b130263f}{Sqrt} = \hyperlink{structFunG_1_1Pow}{Pow}$<$ 1, 2 $>$
\begin{DoxyCompactList}\small\item\em Square root including first three derivatives (based on sqrt(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
using \hyperlink{group__CMathGroup_ga2e4363ad8400e1c8431c10de2152ec2b}{Cbrt} = \hyperlink{structFunG_1_1Pow}{Pow}$<$ 1, 3 $>$
\begin{DoxyCompactList}\small\item\em Third root including first three derivatives (based on sqrt(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
using \hyperlink{group__CMathGroup_ga9bcbef859d7ffd0d6570d69e1bd8503a}{Cbrt2} = \hyperlink{structFunG_1_1Pow}{Pow}$<$ 2, 3 $>$
\begin{DoxyCompactList}\small\item\em Third root squared including first three derivatives (based on sqrt(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
{\footnotesize template$<$class F $>$ }\\using \hyperlink{namespaceFunG_a195ac37d8696970c89b112c81a1e4d6e}{decay\+\_\+t} = typename \hyperlink{structFunG_1_1Decay}{Decay}$<$ std\+::decay\+\_\+t$<$ F $>$ $>$\+::type
\begin{DoxyCompactList}\small\item\em Access underlying type (if it is hidden by expression templates). \end{DoxyCompactList}\item 
{\footnotesize template$<$class F $>$ }\\using \hyperlink{namespaceFunG_a6dd0f05fb05ea031b7b9678fe3730c73}{is\+\_\+arithmetic} = std\+::integral\+\_\+constant$<$ bool, std\+::is\+\_\+arithmetic$<$ F $>$\+::value$\vert$$\vert$\hyperlink{structFunG_1_1IsArithmetic}{Is\+Arithmetic}$<$ F $>$\+::value $>$
\item 
{\footnotesize template$<$class... Types$>$ }\\using \hyperlink{namespaceFunG_a0cde667596590eb8d32e4a5ee76ddbb9}{void\+\_\+t} = typename Detail\+::voider$<$ Types...$>$\+::type
\begin{DoxyCompactList}\small\item\em Most fascinating type ever. Is void for all input types. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , int id$>$ }\\using \hyperlink{namespaceFunG_a3d589ef7d011a46a72847eabcbbb4532}{Variable\+\_\+t} = typename Variable\+Detail\+::\+Variable\+Type$<$ F, id $>$\+::type
\begin{DoxyCompactList}\small\item\em Get underlying type of variable with index id. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gad26443b289325876cffdaadfca770d51}{asin} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \arcsin\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$\+Function$>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_ga7e9b2ac717cd2350663293cb66ba6cbd}{cos} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \cos\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga00135c8521411f13813f9b972ea4e231}{exp} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \exp(f) $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga7724faf7db6e9583ac91df322c26ecf5}{exp2} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $2^f$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga31313571b08f65b853643e14fc8fc714}{ln} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \mathrm{ln}\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gae9506f4e0e6fad4f756f636044697bfe}{log10} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \mathrm{log}_{10}\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gacd6be7e9de7bbd54c852f0acf0c7d2c2}{log2} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \mathrm{log}_{2}\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga136c890475e48f88469a737d95368d05}{sqrt} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sqrt{f} $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gaa7f2552adfb8ec41aeb685adddd8bf98}{cbrt} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sqrt[3]{f} $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gafd27322fb64c6df3366f384c93819a06}{cbrt2} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sqrt[3]{f^2}$. \end{DoxyCompactList}\item 
{\footnotesize template$<$int k, int l, class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gaecae6fa60bbfc0eb1867581ee4577d4e}{pow} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ f^{k/l} $. \end{DoxyCompactList}\item 
{\footnotesize template$<$int k, class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gab52ffe2efd379aad7ea322de46103465}{pow} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ f^k,\ k\in\mathbb{N}$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga663fdbe7a8977cba529c7c33981b7738}{sin} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sin\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gae03f57bd4efb4449ad1dc60cb74c742d}{tan} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \tan\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg $>$ }\\auto \hyperlink{namespaceFunG_a65c509062b62b3303268cabc97b75a65}{constant} (const Arg \&x)
\begin{DoxyCompactList}\small\item\em Generate a constant function that stores its argument as constant reference. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gac269eefc1abb994044e1634c20a98061}{incompressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (double c\+Cells, double k1, double k2, double kappa, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for adipose tissue of \cite{Sommer2013}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga01ab128bcf179f4431b0270179af9e20}{incompressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for adipose tissue of \cite{Sommer2013}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga5c3388564c0420b62e58f48c739d27f1}{compressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (double c\+Cells, double k1, double k2, double kappa, double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for adipose tissue of \cite{Sommer2013}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga27bb3f7c579ce8c21a69ea4d4d0169d7}{compressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for adipose tissue of \cite{Sommer2013}. Material parameters are taken from the same publication, Table 2, i.\+e. $c_\mathrm{Cells}=0.15 (\,\mathrm{kPa})$, $k_1=0.8 (\,\mathrm{kPa})$, $k_2=47.3$ and $\kappa=0.09$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gafcc36a1958899ca9246c4c1b3c9bfd85}{incompressible\+Muscle\+Tissue\+\_\+\+Martins} (double c, double b, double A, double a, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Incompressible version of the model for muscle tissue of \cite{Martins1998}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga9e414585a90b1988e9fa88d17d875055}{incompressible\+Muscle\+Tissue\+\_\+\+Martins} (const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Incompressible version of the model for muscle tissue of \cite{Martins1998}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gad831914c493a3da04ed40c3c0ce87a62}{compressible\+Muscle\+Tissue\+\_\+\+Martins} (double c, double b, double A, double a, double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for muscle tissue of \cite{Martins1998}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga46a70ccb2285e12addad87b6a8aaaae8}{compressible\+Muscle\+Tissue\+\_\+\+Martins} (double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for muscle tissue of \cite{Martins1998}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gaa20bf15ef6976d64d89490429035b2c4}{incompressible\+Skin\+\_\+\+Hendriks} (double c0, double c1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for skin tissue of \cite{Hendriks2005}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gad8653218bd2afb4e3cfd601a5142956c}{incompressible\+Skin\+\_\+\+Hendriks} (const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for skin tissue of \cite{Hendriks2005}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga07b4c52c6ecf7e72f73ab5832fb262cd}{compressible\+Skin\+\_\+\+Hendriks} (double c0, double c1, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for skin tissue of \cite{Hendriks2005}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga42721e772b7eada1b0bca98247ad440f}{compressible\+Skin\+\_\+\+Hendriks} (double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for skin tissue of \cite{Hendriks2005}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Vector $>$ }\\auto \hyperlink{namespaceFunG_aab17a1468e61f58564333b3fcd7900d6}{heat\+Model} (double c, double d, Scalar u, const Vector \&du)
\begin{DoxyCompactList}\small\item\em Yield surface $ \frac{\beta}{3}\iota_1(\sigma) + J_2(\sigma)-offset $, where $\iota_1$ is the first principal and $J_2$ is the second deviatoric invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gace19173e33490aadd36ae3a03fd1d85c}{incompressible\+Mooney\+Rivlin} (double c0, double c1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate an \char`\"{}incompressible\char`\"{} Mooney-\/\+Rivlin material law $ W(F)=c_0\iota_1(F^T F) + c_1\iota_2(F^T F) $, where $\iota_1$ is the first and $\iota_2$ the second principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_ga9a1894daa10a0bdcc620c6c41ecb6f19}{compressible\+Mooney\+Rivlin} (double c0, double c1, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate a compressible Mooney-\/\+Rivlin material law $ W(F)=c_0\iota_1(F^T F) + c_1\iota_2(F^T F) + d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $, where $\iota_1$ is the first and $\iota_2$ the second principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_ga5bb28aef7006413775791998936d6b81}{incompressible\+Neo\+Hooke} (double c, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate an \char`\"{}incompressible\char`\"{} neo-\/\+Hookean material law $ W(F)=c\iota_1(F^T F) $, where $\iota_1$ is the first principal matrix invariant . \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gaf6f5ab6a379ef03d513acc5042731a01}{modified\+Incompressible\+Neo\+Hooke} (double c, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate an \char`\"{}incompressible\char`\"{} neo-\/\+Hookean material law $ W(F)=c\bar\iota_1(F^T F) $, where $\bar\iota_1$ is the modified first principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gac5c39cd9de55f4f0220a806cf28a7b30}{compressible\+Neo\+Hooke} (double c, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate a compressible neo-\/\+Hookean material law $ W(F)=c\iota_1(F^T F)+d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $, where $\iota_1$ is the first principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gac10942df03f037afdf0a81d330361a6b}{modified\+Compressible\+Neo\+Hooke} (double c, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate a compressible neo-\/\+Hookean material law $ W(F)=c\bar\iota_1(F^T F)+d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $, where $\bar\iota_1$ is the modified first principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix $>$ }\\auto \hyperlink{namespaceFunG_ad26faeb264bb4b1cd7e70f3811c366c8}{volumetric\+Penalty} (double d0, double d1, const Matrix \&A)
\begin{DoxyCompactList}\small\item\em Create volumetric penalty function composed of a penalty for inflation and one for compression. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix $>$ }\\auto \hyperlink{namespaceFunG_aaf30b9c36ed86e01b94f6b7c1d95cae8}{volumetric\+Quad\+And\+Log} (double d0, double d1, const Matrix \&A)
\begin{DoxyCompactList}\small\item\em Create the volumetric penalty function $ d_0 j^2 + d_1 \log(j),\ j=\det(A) $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix $>$ }\\auto \hyperlink{namespaceFunG_adf4be5df85ea9df10cc9e11c11aaeb7b}{volumetric\+Hartmann\+Neff} (double d0, double d1, const Matrix \&A)
\begin{DoxyCompactList}\small\item\em Create the volumetric penalty function $ d_0 j^5 + d_1 j^{-5},\ j=\det(A) $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix $>$ }\\auto \hyperlink{namespaceFunG_a4784211358c877f05ad9426850303273}{yield\+Surface} (double beta, double offset, Matrix sigma=\hyperlink{group__LinearAlgebraGroup_ga88a596b8526c0ed98ce241244fb85948}{Linear\+Algebra\+::unit\+Matrix}$<$ Matrix $>$())
\begin{DoxyCompactList}\small\item\em Yield surface $ \frac{\beta}{3}\iota_1(\sigma) + J_2(\sigma)-offset $, where $\iota_1$ is the first principal and $J_2$ is the second deviatoric invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F $>$ }\\auto \hyperlink{namespaceFunG_a3a2af76439713dc7635e0c538ac34f15}{finalize} (const F \&f)
\begin{DoxyCompactList}\small\item\em Finish function definition. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$\+F$>$() $\vert$$\vert$                                      Checks\+::is\+Function$<$\+G$>$() $>$$>$ }\\auto \hyperlink{namespaceFunG_ac7f61d48ff610ec4be8ee6994d165077}{operator+} (const F \&f, const G \&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}+\char`\"{}-\/operator for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$\+F$>$() $\vert$$\vert$ Checks\+::is\+Function$<$\+G$>$() $>$$>$ }\\auto \hyperlink{namespaceFunG_a014be932d3b4eb377d8e60271e864438}{operator$\ast$} (const F \&f, const G \&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}$\ast$\char`\"{}-\/operator for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$\+F$>$() $>$$>$ }\\auto \hyperlink{namespaceFunG_aeb22ff63cd78cb63d81b601c656da2c1}{operator$^\wedge$} (const F \&f, int k)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}$^\wedge$\char`\"{}-\/operator for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+F$>$() \&\&                                     Checks\+::is\+Function$<$\+G$>$()$>$$>$ }\\auto \hyperlink{namespaceFunG_a56701b5e83b96d2d6cc5c482e36caa39}{operator$<$$<$} (const F \&f, const G \&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}$<$$<$\char`\"{}-\/operator for chaining functions $f$ and $g$ to $ f \circ g $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class T , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ F $>$()\&\&!\+Checks\+::is\+Function$<$ T $>$()$>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_aa0c4552dee9179fb50b57ece863d835a}{operator-\/} (const F \&f, const T \&t)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}-\/\char`\"{}-\/operator for the generation of functions. Here the second argument is a constant that is wrapped in to an object of type \hyperlink{structFunG_1_1Constant}{Constant}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class T , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ T, decltype(std\+::declval$<$ F $>$()())$>$\+::value \&\&\+Checks\+::is\+Function$<$ F $>$()$>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a7f522d98a8d5bc8c3b11599d3136ded4}{operator-\/} (const T \&t, const F \&f)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}-\/\char`\"{}-\/operator for the generation of functions. Here the first argument is a constant that is wrapped in to an object of type \hyperlink{structFunG_1_1Constant}{Constant}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg $>$ }\\auto \hyperlink{namespaceFunG_a165e879e76d3a2a8906938f3658445ce}{identity} (const Arg \&x)
\begin{DoxyCompactList}\small\item\em Construct Identity$<$\+Arg$>$(x). \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Other\+Scalar , int n, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Dune\+::\+Field\+Vector$<$ Scalar, n $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a5e258023361844926f485229c62a733b}{operator$\ast$} (const Dune\+::\+Field\+Vector$<$ Scalar, n $>$ \&a, const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&b)
\begin{DoxyCompactList}\small\item\em Computation of the l2 scalar product for Dune\+::\+Field\+Vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_abadb8da34a5abc3dde0107231ab91c6f}{operator$\ast$} (const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&A, const Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ \&x)
\begin{DoxyCompactList}\small\item\em Define matrix-\/vector multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $y=Ax$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$, Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a19a9d7b55b56f5101560034413a1dbfe}{operator$\ast$} (const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&x, const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&A)
\begin{DoxyCompactList}\small\item\em Define vector-\/matrix multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $x^T A = y^T$ resp. $y=A^T x$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg, Scalar\+Arg $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a9b303ce8718a6f64b035e7e782370734}{operator$\ast$} (Scalar\+Arg a, Arg x)
\begin{DoxyCompactList}\small\item\em Defines operator$\ast$ for multiplication with built-\/in arithmetic types from the left if undefined and in-\/place multiplication (operator$\ast$=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg, Scalar\+Arg $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a3cd5a2cb1abba842154691bb84aab896}{operator$\ast$} (Arg x, Scalar\+Arg a)
\begin{DoxyCompactList}\small\item\em Defines operator$\ast$ for multiplication with built-\/in arithmetic types from the right if undefined and in-\/place multiplication (operator$\ast$=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg1 , class Arg2 , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg1 $>$()\&\&!\+Checks\+::is\+Function$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ Arg1 $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg1, Arg2 $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_ad023f2d2273af693f2b4ebceeb296dc8}{operator$\ast$} (Arg1 x, const Arg2 \&y)
\begin{DoxyCompactList}\small\item\em Defines operator$\ast$ for multiplication of non-\/arithmetic types if undefined and in-\/place multiplication (operator$\ast$=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg1 , class Arg2 , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg1 $>$()\&\&!\+Checks\+::is\+Function$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ Arg1 $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg1, Arg2 $>$()\&\&!\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::has\+Mem\+Fn\+\_\+rightmultiplyany$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a6e4d3266e119cd102800bf5c091e57fd}{operator$\ast$} (Arg1 x, const Arg2 \&y)
\begin{DoxyCompactList}\small\item\em Defines operator$\ast$ for multiplication of non-\/arithmetic types if undefined and in-\/place multiplication is provided in terms of the member function rightmultiplyany() (such as for Dune\+::\+Field\+Matrix). \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Summation$<$ Arg $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Summation$<$ Arg $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a063d3e8c19dbea3ee1396736fecb64e1}{operator+} (Arg x, const Arg \&y)
\begin{DoxyCompactList}\small\item\em Defines operator+ if not yet defined and in-\/place summation (operator+=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Constant\+Size$<$ Matrix $>$()$>$ $\ast$  = nullptr$>$ }\\Matrix \hyperlink{namespaceFunG_a0211d0d26c669d56b5113fd2292902e5}{add\+Transposed} (Matrix \&A)
\begin{DoxyCompactList}\small\item\em Overwrites $A$ with $A+A^T$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() $\vert$$\vert$ std\+::is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ }\\Matrix \hyperlink{namespaceFunG_a649b4470d6def401959bfea3a368c48c}{zero} ()
\item 
{\footnotesize template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$!\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() \&\& !std\+::is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ }\\constexpr Matrix \hyperlink{namespaceFunG_ae633433339ba30207aa526e54e3924b4}{zero} (int rows, int cols)
\item 
{\footnotesize template$<$int id, class T $>$ }\\\hyperlink{structFunG_1_1Variable}{Variable}$<$ T, id $>$ \hyperlink{namespaceFunG_a1c474456411f028e14eab67ff6eebe0c}{variable} (const T \&t)
\begin{DoxyCompactList}\small\item\em Generate variable from input type. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Main namespace of the Fun\+G library. 

\begin{DoxySeeAlso}{See also}
\hyperlink{group__MathematicalOperationsGroup}{Mathematical Operations} 

\hyperlink{group__CMathGroup}{Common Mathematical Functions} 

\hyperlink{group__LinearAlgebraGroup}{Linear Algebra} 
\end{DoxySeeAlso}


\subsection{Typedef Documentation}
\hypertarget{namespaceFunG_a195ac37d8696970c89b112c81a1e4d6e}{}\index{Fun\+G@{Fun\+G}!decay\+\_\+t@{decay\+\_\+t}}
\index{decay\+\_\+t@{decay\+\_\+t}!Fun\+G@{Fun\+G}}
\subsubsection[{decay\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F $>$ using {\bf Fun\+G\+::decay\+\_\+t} = typedef typename {\bf Decay}$<$ std\+::decay\+\_\+t$<$F$>$ $>$\+::type}\label{namespaceFunG_a195ac37d8696970c89b112c81a1e4d6e}


Access underlying type (if it is hidden by expression templates). 

\hypertarget{namespaceFunG_a6dd0f05fb05ea031b7b9678fe3730c73}{}\index{Fun\+G@{Fun\+G}!is\+\_\+arithmetic@{is\+\_\+arithmetic}}
\index{is\+\_\+arithmetic@{is\+\_\+arithmetic}!Fun\+G@{Fun\+G}}
\subsubsection[{is\+\_\+arithmetic}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F $>$ using {\bf Fun\+G\+::is\+\_\+arithmetic} = typedef std\+::integral\+\_\+constant$<$ bool , std\+::is\+\_\+arithmetic$<$F$>$\+::value $\vert$$\vert$ {\bf Is\+Arithmetic}$<$F$>$\+::value $>$}\label{namespaceFunG_a6dd0f05fb05ea031b7b9678fe3730c73}
\hypertarget{namespaceFunG_a3d589ef7d011a46a72847eabcbbb4532}{}\index{Fun\+G@{Fun\+G}!Variable\+\_\+t@{Variable\+\_\+t}}
\index{Variable\+\_\+t@{Variable\+\_\+t}!Fun\+G@{Fun\+G}}
\subsubsection[{Variable\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , int id$>$ using {\bf Fun\+G\+::\+Variable\+\_\+t} = typedef typename Variable\+Detail\+::\+Variable\+Type$<$F,id$>$\+::type}\label{namespaceFunG_a3d589ef7d011a46a72847eabcbbb4532}


Get underlying type of variable with index id. 

\hypertarget{namespaceFunG_a0cde667596590eb8d32e4a5ee76ddbb9}{}\index{Fun\+G@{Fun\+G}!void\+\_\+t@{void\+\_\+t}}
\index{void\+\_\+t@{void\+\_\+t}!Fun\+G@{Fun\+G}}
\subsubsection[{void\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class... Types$>$ using {\bf Fun\+G\+::void\+\_\+t} = typedef typename Detail\+::voider$<$Types...$>$\+::type}\label{namespaceFunG_a0cde667596590eb8d32e4a5ee76ddbb9}


Most fascinating type ever. Is void for all input types. 



\subsection{Function Documentation}
\hypertarget{namespaceFunG_a0211d0d26c669d56b5113fd2292902e5}{}\index{Fun\+G@{Fun\+G}!add\+Transposed@{add\+Transposed}}
\index{add\+Transposed@{add\+Transposed}!Fun\+G@{Fun\+G}}
\subsubsection[{add\+Transposed}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Constant\+Size$<$ Matrix $>$()$>$ $\ast$  = nullptr$>$ Matrix Fun\+G\+::add\+Transposed (
\begin{DoxyParamCaption}
\item[{Matrix \&}]{A}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a0211d0d26c669d56b5113fd2292902e5}


Overwrites $A$ with $A+A^T$. 

\begin{DoxyReturn}{Returns}
$A+A^T$ 
\end{DoxyReturn}
\hypertarget{namespaceFunG_a65c509062b62b3303268cabc97b75a65}{}\index{Fun\+G@{Fun\+G}!constant@{constant}}
\index{constant@{constant}!Fun\+G@{Fun\+G}}
\subsubsection[{constant}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg $>$ auto Fun\+G\+::constant (
\begin{DoxyParamCaption}
\item[{const Arg \&}]{x}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a65c509062b62b3303268cabc97b75a65}


Generate a constant function that stores its argument as constant reference. 

This admits to use variable constant arguments, i.\+e. parameters that we want to study. Wrap a constant. \begin{DoxyReturn}{Returns}
Constant$<$\+Arg$>$(x) 
\end{DoxyReturn}
\hypertarget{namespaceFunG_a3a2af76439713dc7635e0c538ac34f15}{}\index{Fun\+G@{Fun\+G}!finalize@{finalize}}
\index{finalize@{finalize}!Fun\+G@{Fun\+G}}
\subsubsection[{finalize}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F $>$ auto Fun\+G\+::finalize (
\begin{DoxyParamCaption}
\item[{const F \&}]{f}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a3a2af76439713dc7635e0c538ac34f15}


Finish function definition. 

Adds the definition of possibly undefined vanishing higher order derivatives. \hypertarget{namespaceFunG_aab17a1468e61f58564333b3fcd7900d6}{}\index{Fun\+G@{Fun\+G}!heat\+Model@{heat\+Model}}
\index{heat\+Model@{heat\+Model}!Fun\+G@{Fun\+G}}
\subsubsection[{heat\+Model}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Vector $>$ auto Fun\+G\+::heat\+Model (
\begin{DoxyParamCaption}
\item[{double}]{c, }
\item[{double}]{d, }
\item[{Scalar}]{u, }
\item[{const Vector \&}]{du}
\end{DoxyParamCaption}
)}\label{namespaceFunG_aab17a1468e61f58564333b3fcd7900d6}


Yield surface $ \frac{\beta}{3}\iota_1(\sigma) + J_2(\sigma)-offset $, where $\iota_1$ is the first principal and $J_2$ is the second deviatoric invariant. 

Weak model for nonlinear heat transfer $ (c+du^2)\nabla u $. 
\begin{DoxyParams}{Parameters}
{\em c} & weighing of linearity \\
\hline
{\em d} & weighing of nonlinearity \\
\hline
{\em u} & heat \\
\hline
{\em du} & heat gradient \\
\hline
\end{DoxyParams}
\hypertarget{namespaceFunG_a165e879e76d3a2a8906938f3658445ce}{}\index{Fun\+G@{Fun\+G}!identity@{identity}}
\index{identity@{identity}!Fun\+G@{Fun\+G}}
\subsubsection[{identity}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg $>$ auto Fun\+G\+::identity (
\begin{DoxyParamCaption}
\item[{const Arg \&}]{x}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a165e879e76d3a2a8906938f3658445ce}


Construct Identity$<$\+Arg$>$(x). 

\hypertarget{namespaceFunG_a5e258023361844926f485229c62a733b}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Other\+Scalar , int n, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Dune\+::\+Field\+Vector$<$ Scalar, n $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const Dune\+::\+Field\+Vector$<$ Scalar, n $>$ \&}]{a, }
\item[{const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&}]{b}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a5e258023361844926f485229c62a733b}


Computation of the l2 scalar product for Dune\+::\+Field\+Vector. 

\hypertarget{namespaceFunG_abadb8da34a5abc3dde0107231ab91c6f}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&}]{A, }
\item[{const Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ \&}]{x}
\end{DoxyParamCaption}
)}\label{namespaceFunG_abadb8da34a5abc3dde0107231ab91c6f}


Define matrix-\/vector multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $y=Ax$. 

\hypertarget{namespaceFunG_a19a9d7b55b56f5101560034413a1dbfe}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$, Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&}]{x, }
\item[{const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&}]{A}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a19a9d7b55b56f5101560034413a1dbfe}


Define vector-\/matrix multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $x^T A = y^T$ resp. $y=A^T x$. 

\hypertarget{namespaceFunG_a9b303ce8718a6f64b035e7e782370734}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg, Scalar\+Arg $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{Scalar\+Arg}]{a, }
\item[{Arg}]{x}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a9b303ce8718a6f64b035e7e782370734}


Defines operator$\ast$ for multiplication with built-\/in arithmetic types from the left if undefined and in-\/place multiplication (operator$\ast$=()) is supported. 

\hypertarget{namespaceFunG_a3cd5a2cb1abba842154691bb84aab896}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg, Scalar\+Arg $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{Arg}]{x, }
\item[{Scalar\+Arg}]{a}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a3cd5a2cb1abba842154691bb84aab896}


Defines operator$\ast$ for multiplication with built-\/in arithmetic types from the right if undefined and in-\/place multiplication (operator$\ast$=()) is supported. 

\hypertarget{namespaceFunG_ad023f2d2273af693f2b4ebceeb296dc8}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg1 , class Arg2 , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg1 $>$()\&\&!\+Checks\+::is\+Function$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ Arg1 $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg1, Arg2 $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{Arg1}]{x, }
\item[{const Arg2 \&}]{y}
\end{DoxyParamCaption}
)}\label{namespaceFunG_ad023f2d2273af693f2b4ebceeb296dc8}


Defines operator$\ast$ for multiplication of non-\/arithmetic types if undefined and in-\/place multiplication (operator$\ast$=()) is supported. 

\hypertarget{namespaceFunG_a6e4d3266e119cd102800bf5c091e57fd}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg1 , class Arg2 , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg1 $>$()\&\&!\+Checks\+::is\+Function$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ Arg1 $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Multiplication$<$ Arg1, Arg2 $>$()\&\&!\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Multiplication$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::has\+Mem\+Fn\+\_\+rightmultiplyany$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{Arg1}]{x, }
\item[{const Arg2 \&}]{y}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a6e4d3266e119cd102800bf5c091e57fd}


Defines operator$\ast$ for multiplication of non-\/arithmetic types if undefined and in-\/place multiplication is provided in terms of the member function rightmultiplyany() (such as for Dune\+::\+Field\+Matrix). 

\hypertarget{namespaceFunG_a014be932d3b4eb377d8e60271e864438}{}\index{Fun\+G@{Fun\+G}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$\+F$>$() $\vert$$\vert$ Checks\+::is\+Function$<$\+G$>$() $>$$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const F \&}]{f, }
\item[{const G \&}]{g}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a014be932d3b4eb377d8e60271e864438}


overload of \char`\"{}$\ast$\char`\"{}-\/operator for the generation of functions. 

This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \hypertarget{namespaceFunG_a063d3e8c19dbea3ee1396736fecb64e1}{}\index{Fun\+G@{Fun\+G}!operator+@{operator+}}
\index{operator+@{operator+}!Fun\+G@{Fun\+G}}
\subsubsection[{operator+}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!std\+::is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::has\+Free\+\_\+\+Summation$<$ Arg $>$()\&\&\+Checks\+::has\+Mem\+Fn\+\_\+\+In\+Place\+Summation$<$ Arg $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator+ (
\begin{DoxyParamCaption}
\item[{Arg}]{x, }
\item[{const Arg \&}]{y}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a063d3e8c19dbea3ee1396736fecb64e1}


Defines operator+ if not yet defined and in-\/place summation (operator+=()) is supported. 

\hypertarget{namespaceFunG_ac7f61d48ff610ec4be8ee6994d165077}{}\index{Fun\+G@{Fun\+G}!operator+@{operator+}}
\index{operator+@{operator+}!Fun\+G@{Fun\+G}}
\subsubsection[{operator+}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$\+F$>$() $\vert$$\vert$                                      Checks\+::is\+Function$<$\+G$>$() $>$$>$ auto Fun\+G\+::operator+ (
\begin{DoxyParamCaption}
\item[{const F \&}]{f, }
\item[{const G \&}]{g}
\end{DoxyParamCaption}
)}\label{namespaceFunG_ac7f61d48ff610ec4be8ee6994d165077}


overload of \char`\"{}+\char`\"{}-\/operator for the generation of functions. 

This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \hypertarget{namespaceFunG_aa0c4552dee9179fb50b57ece863d835a}{}\index{Fun\+G@{Fun\+G}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!Fun\+G@{Fun\+G}}
\subsubsection[{operator-\/}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class T , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ F $>$()\&\&!\+Checks\+::is\+Function$<$ T $>$()$>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const F \&}]{f, }
\item[{const T \&}]{t}
\end{DoxyParamCaption}
)}\label{namespaceFunG_aa0c4552dee9179fb50b57ece863d835a}


overload of \char`\"{}-\/\char`\"{}-\/operator for the generation of functions. Here the second argument is a constant that is wrapped in to an object of type \hyperlink{structFunG_1_1Constant}{Constant}. 

This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \hypertarget{namespaceFunG_a7f522d98a8d5bc8c3b11599d3136ded4}{}\index{Fun\+G@{Fun\+G}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!Fun\+G@{Fun\+G}}
\subsubsection[{operator-\/}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class T , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ T, decltype(std\+::declval$<$ F $>$()())$>$\+::value \&\&\+Checks\+::is\+Function$<$ F $>$()$>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const T \&}]{t, }
\item[{const F \&}]{f}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a7f522d98a8d5bc8c3b11599d3136ded4}


overload of \char`\"{}-\/\char`\"{}-\/operator for the generation of functions. Here the first argument is a constant that is wrapped in to an object of type \hyperlink{structFunG_1_1Constant}{Constant}. 

This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \hypertarget{namespaceFunG_a56701b5e83b96d2d6cc5c482e36caa39}{}\index{Fun\+G@{Fun\+G}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$<$$<$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+F$>$() \&\&                                     Checks\+::is\+Function$<$\+G$>$()$>$$>$ auto Fun\+G\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{const F \&}]{f, }
\item[{const G \&}]{g}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a56701b5e83b96d2d6cc5c482e36caa39}


overload of \char`\"{}$<$$<$\char`\"{}-\/operator for chaining functions $f$ and $g$ to $ f \circ g $. 

This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \hypertarget{namespaceFunG_aeb22ff63cd78cb63d81b601c656da2c1}{}\index{Fun\+G@{Fun\+G}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!Fun\+G@{Fun\+G}}
\subsubsection[{operator$^\wedge$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$\+F$>$() $>$$>$ auto Fun\+G\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{const F \&}]{f, }
\item[{int}]{k}
\end{DoxyParamCaption}
)}\label{namespaceFunG_aeb22ff63cd78cb63d81b601c656da2c1}


overload of \char`\"{}$^\wedge$\char`\"{}-\/operator for the generation of functions. 

This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \hypertarget{namespaceFunG_a1c474456411f028e14eab67ff6eebe0c}{}\index{Fun\+G@{Fun\+G}!variable@{variable}}
\index{variable@{variable}!Fun\+G@{Fun\+G}}
\subsubsection[{variable}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int id, class T $>$ {\bf Variable}$<$T,id$>$ Fun\+G\+::variable (
\begin{DoxyParamCaption}
\item[{const T \&}]{t}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a1c474456411f028e14eab67ff6eebe0c}


Generate variable from input type. 

\hypertarget{namespaceFunG_adf4be5df85ea9df10cc9e11c11aaeb7b}{}\index{Fun\+G@{Fun\+G}!volumetric\+Hartmann\+Neff@{volumetric\+Hartmann\+Neff}}
\index{volumetric\+Hartmann\+Neff@{volumetric\+Hartmann\+Neff}!Fun\+G@{Fun\+G}}
\subsubsection[{volumetric\+Hartmann\+Neff}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix $>$ auto Fun\+G\+::volumetric\+Hartmann\+Neff (
\begin{DoxyParamCaption}
\item[{double}]{d0, }
\item[{double}]{d1, }
\item[{const Matrix \&}]{A}
\end{DoxyParamCaption}
)}\label{namespaceFunG_adf4be5df85ea9df10cc9e11c11aaeb7b}


Create the volumetric penalty function $ d_0 j^5 + d_1 j^{-5},\ j=\det(A) $. 

\hypertarget{namespaceFunG_ad26faeb264bb4b1cd7e70f3811c366c8}{}\index{Fun\+G@{Fun\+G}!volumetric\+Penalty@{volumetric\+Penalty}}
\index{volumetric\+Penalty@{volumetric\+Penalty}!Fun\+G@{Fun\+G}}
\subsubsection[{volumetric\+Penalty}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Inflation , class Compression , class Matrix $>$ auto Fun\+G\+::volumetric\+Penalty (
\begin{DoxyParamCaption}
\item[{double}]{d0, }
\item[{double}]{d1, }
\item[{const Matrix \&}]{A}
\end{DoxyParamCaption}
)}\label{namespaceFunG_ad26faeb264bb4b1cd7e70f3811c366c8}


Create volumetric penalty function composed of a penalty for inflation and one for compression. 

\hypertarget{namespaceFunG_aaf30b9c36ed86e01b94f6b7c1d95cae8}{}\index{Fun\+G@{Fun\+G}!volumetric\+Quad\+And\+Log@{volumetric\+Quad\+And\+Log}}
\index{volumetric\+Quad\+And\+Log@{volumetric\+Quad\+And\+Log}!Fun\+G@{Fun\+G}}
\subsubsection[{volumetric\+Quad\+And\+Log}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix $>$ auto Fun\+G\+::volumetric\+Quad\+And\+Log (
\begin{DoxyParamCaption}
\item[{double}]{d0, }
\item[{double}]{d1, }
\item[{const Matrix \&}]{A}
\end{DoxyParamCaption}
)}\label{namespaceFunG_aaf30b9c36ed86e01b94f6b7c1d95cae8}


Create the volumetric penalty function $ d_0 j^2 + d_1 \log(j),\ j=\det(A) $. 

\hypertarget{namespaceFunG_a4784211358c877f05ad9426850303273}{}\index{Fun\+G@{Fun\+G}!yield\+Surface@{yield\+Surface}}
\index{yield\+Surface@{yield\+Surface}!Fun\+G@{Fun\+G}}
\subsubsection[{yield\+Surface}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix $>$ auto Fun\+G\+::yield\+Surface (
\begin{DoxyParamCaption}
\item[{double}]{beta, }
\item[{double}]{offset, }
\item[{Matrix}]{sigma = {\ttfamily {\bf Linear\+Algebra\+::unit\+Matrix}$<$Matrix$>$()}}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a4784211358c877f05ad9426850303273}


Yield surface $ \frac{\beta}{3}\iota_1(\sigma) + J_2(\sigma)-offset $, where $\iota_1$ is the first principal and $J_2$ is the second deviatoric invariant. 

\hypertarget{namespaceFunG_a649b4470d6def401959bfea3a368c48c}{}\index{Fun\+G@{Fun\+G}!zero@{zero}}
\index{zero@{zero}!Fun\+G@{Fun\+G}}
\subsubsection[{zero}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() $\vert$$\vert$ std\+::is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ Matrix Fun\+G\+::zero (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespaceFunG_a649b4470d6def401959bfea3a368c48c}
Requires that a specialization of struct \hyperlink{structFunG_1_1Zero}{Zero} exists for Matrix. \begin{DoxyReturn}{Returns}
constant size zero matrix 
\end{DoxyReturn}
\hypertarget{namespaceFunG_ae633433339ba30207aa526e54e3924b4}{}\index{Fun\+G@{Fun\+G}!zero@{zero}}
\index{zero@{zero}!Fun\+G@{Fun\+G}}
\subsubsection[{zero}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$!\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() \&\& !std\+::is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ constexpr Matrix Fun\+G\+::zero (
\begin{DoxyParamCaption}
\item[{int}]{rows, }
\item[{int}]{cols}
\end{DoxyParamCaption}
)}\label{namespaceFunG_ae633433339ba30207aa526e54e3924b4}
Requires that a specialization of struct \hyperlink{structFunG_1_1Zero}{Zero} exists for Matrix. \begin{DoxyReturn}{Returns}
dynamic size zero matrix 
\end{DoxyReturn}
